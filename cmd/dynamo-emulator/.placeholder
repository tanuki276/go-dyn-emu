package api

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"

        "github.com/syndtr/goleveldb/leveldb"
        "github.com/syndtr/goleveldb/leveldb/util"
        "Emulator-fr-virtuelle-Datenbanken-gobes/pkg/core"
        "Emulator-fr-virtuelle-Datenbanken-gobes/pkg/model"
)

type CreateTableInput struct {
        TableName string `json:"TableName"`
        KeySchema []struct {
                AttributeName string `json:"AttributeName"`
                KeyType string `json:"KeyType"`
        } `json:"KeySchema"`
}

func (s *Server) updateGSI(batch *leveldb.Batch, schema model.TableSchema, oldRecord model.Record, newRecord model.Record) {
        if len(schema.GSIs) == 0 {
                return
        }

        mainPKAV, _ := model.GetAttributeValueString(newRecord[schema.PartitionKey])

        for _, gsi := range schema.GSIs {
                oldGpkVal := ""
                oldGskVal := ""
                newGpkVal := ""
                newGskVal := ""


                gpkAVOld, okOld := oldRecord[gsi.PartitionKey]
                if okOld { oldGpkVal, _ = model.GetAttributeValueString(gpkAVOld) }

                gpkAVNew, okNew := newRecord[gsi.PartitionKey]
                if okNew { newGpkVal, _ = model.GetAttributeValueString(gpkAVNew) }

                if gsi.SortKey != "" {
                        gskAVOld, okOld := oldRecord[gsi.SortKey]
                        if okOld { gskValOld, _ := model.GetAttributeValueString(gskAVOld); oldGskVal = gskValOld }

                        gskAVNew, okNew := newRecord[gsi.SortKey]
                        if okNew { gskValNew, _ := model.GetAttributeValueString(gskAVNew); newGskVal = gskValNew }
                }

                if oldGpkVal != "" && (oldGpkVal != newGpkVal || oldGskVal != newGskVal) {
                        oldGSIKey := model.BuildGSILevelDBKey(gsi.IndexName, oldGpkVal, oldGskVal, mainPKAV)
                        batch.Delete([]byte(oldGSIKey))
                }

                if newGpkVal != "" {
                        newGSIKey := model.BuildGSILevelDBKey(gsi.IndexName, newGpkVal, newGskVal, mainPKAV)
                        batch.Put([]byte(newGSIKey), []byte{})
                }
        }
}

func (s *Server) handleCreateTable(w http.ResponseWriter, body []byte) {
        var input CreateTableInput
        if err := json.Unmarshal(body, &input); err != nil {
                s.writeDynamoDBError(w, "ValidationException", "Invalid JSON input", http.StatusBadRequest)
                return
        }

        if input.TableName == "" {
                s.writeDynamoDBError(w, "ValidationException", "TableName must be specified", http.StatusBadRequest)
                return
        }

        schema := model.TableSchema{TableName: input.TableName, GSIs: make(map[string]model.GsiSchema)}
        for _, k := range input.KeySchema {
                if k.KeyType == "HASH" {
                        schema.PartitionKey = k.AttributeName
                } else if k.KeyType == "RANGE" {
                        schema.SortKey = k.AttributeName
                }
        }

        s.DB.mu.Lock()
        defer s.DB.mu.Unlock()

        if _, exists := s.DB.Tables[input.TableName]; exists {
                s.writeDynamoDBError(w, "ResourceInUseException", "Table already exists", http.StatusBadRequest)
                return
        }

        s.DB.Tables[input.TableName] = schema

        w.WriteHeader(http.StatusOK)
        w.Write([]byte(fmt.Sprintf(`{"TableDescription": {"TableName": "%s", "TableStatus": "ACTIVE"}}`, input.TableName)))
}

func (s *Server) handlePutItem(w http.ResponseWriter, body []byte) {
        var input model.PutItemInput
        if err := json.Unmarshal(body, &input); err != nil {
                s.writeDynamoDBError(w, "ValidationException", "Invalid JSON input", http.StatusBadRequest)
                return
        }

        s.DB.mu.RLock()
        schema, ok := s.DB.Tables[input.TableName]
        s.DB.mu.RUnlock()
        if !ok {
                s.writeDynamoDBError(w, "ResourceNotFoundException", "Table not found", http.StatusBadRequest)
                return
        }

        pkAV, ok := input.Item[schema.PartitionKey]
        if !ok {
                s.writeDynamoDBError(w, "ValidationException", fmt.Sprintf("Partition Key '%s' value missing", schema.PartitionKey), http.StatusBadRequest)
                return
        }
        pkVal, _ := model.GetAttributeValueString(pkAV)

        var skVal string
        if schema.SortKey != "" {
                skAV, ok := input.Item[schema.SortKey]
                if ok {
                        skVal, _ = model.GetAttributeValueString(skAV)
                }
        }

        levelDBKey := model.BuildLevelDBKey(input.TableName, pkVal, skVal)

        batch := new(leveldb.Batch)

        s.DB.mu.Lock()
        defer s.DB.mu.Unlock()

        oldValue, err := s.DB.DB.Get([]byte(levelDBKey), nil)
        var oldRecord model.Record
        if err != leveldb.ErrNotFound && err != nil {
                http.Error(w, "Internal DB error", http.StatusInternalServerError)
                return
        }
        if err == nil {
                oldRecord, _ = model.UnmarshalRecord(oldValue)
        }

        s.updateGSI(batch, schema, oldRecord, input.Item)

        value, err := model.MarshalRecord(input.Item)
        if err != nil {
                s.writeDynamoDBError(w, "InternalServerError", "Failed to marshal item", http.StatusInternalServerError)
                return
        }
        batch.Put([]byte(levelDBKey), value)

        if err := s.DB.DB.Write(batch, nil); err != nil {
                http.Error(w, "Internal DB error", http.StatusInternalServerError)
                return
        }

        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{}`))
}

type GetItemInput struct {
        TableName string `json:"TableName"`
        Key map[string]model.AttributeValue `json:"Key"`
}

func (s *Server) handleGetItem(w http.ResponseWriter, body []byte) {
        var input GetItemInput
        if err := json.Unmarshal(body, &input); err != nil {
                s.writeDynamoDBError(w, "ValidationException", "Invalid JSON input", http.StatusBadRequest)
                return
        }

        s.DB.mu.RLock()
        schema, ok := s.DB.Tables[input.TableName]
        s.DB.mu.RUnlock()
        if !ok {
                s.writeDynamoDBError(w, "ResourceNotFoundException", "Table not found", http.StatusBadRequest)
                return
        }

        pkAV, ok := input.Key[schema.PartitionKey]
        if !ok {
                s.writeDynamoDBError(w, "ValidationException", fmt.Sprintf("Partition Key '%s' value missing", schema.PartitionKey), http.StatusBadRequest)
                return
        }
        pkVal, _ := model.GetAttributeValueString(pkAV)

        var skVal string
        if schema.SortKey != "" {
                skAV, ok := input.Key[schema.SortKey]
                if ok {
                        skVal, _ = model.GetAttributeValueString(skAV)
                }
        }

        levelDBKey := model.BuildLevelDBKey(input.TableName, pkVal, skVal)

        s.DB.mu.RLock()
        defer s.DB.mu.RUnlock()
        value, err := s.DB.DB.Get([]byte(levelDBKey), nil)
        if err == leveldb.ErrNotFound {
                w.WriteHeader(http.StatusOK)
                w.Write([]byte(`{"Item": {}}`))
                return
        }
        if err != nil {
                http.Error(w, "Internal DB error", http.StatusInternalServerError)
                return
        }

        w.WriteHeader(http.StatusOK)
        fmt.Fprintf(w, `{"Item": %s}`, string(value))
}

type QueryOutput struct {
        Items []model.Record `json:"Items"`
        Count int `json:"Count"`
        ScannedCount int `json:"ScannedCount"`
        LastEvaluatedKey model.Record `json:"LastEvaluatedKey,omitempty"`
}

func (s *Server) handleQuery(w http.ResponseWriter, body []byte) {
        var input model.QueryInput
        if err := json.Unmarshal(body, &input); err != nil {
                s.writeDynamoDBError(w, "ValidationException", "Invalid JSON input", http.StatusBadRequest)
                return
        }

        s.DB.mu.RLock()
        schema, ok := s.DB.Tables[input.TableName]
        s.DB.mu.RUnlock()
        if !ok {
                s.writeDynamoDBError(w, "ResourceNotFoundException", "Table not found", http.StatusBadRequest)
                return
        }

        pkValuePlaceholder, ok := input.ExpressionAttributeValues[":pkval"]
        if !ok {
                s.writeDynamoDBError(w, "ValidationException", "Partition Key value (:pkval) not found in ExpressionAttributeValues", http.StatusBadRequest)
                return
        }
        pkVal, _ := model.GetAttributeValueString(pkValuePlaceholder)

        var iteratorPrefix []byte
        var isGSIQuery bool = false

        if input.IndexName == "" {
                prefix := model.BuildLevelDBKey(input.TableName, pkVal, "")
                iteratorPrefix = []byte(prefix)
        } else {
                s.DB.mu.RLock()
                gsiSchema, exists := schema.GSIs[input.IndexName]
                s.DB.mu.RUnlock()
                if !exists {
                        s.writeDynamoDBError(w, "ValidationException", fmt.Sprintf("Index %s not found", input.IndexName), http.StatusBadRequest)
                        return
                }

                prefix := model.BuildGSILevelDBKey(gsiSchema.IndexName, pkVal, "", "")
                iteratorPrefix = []byte(prefix)
                isGSIQuery = true
        }


        s.DB.mu.RLock()
        defer s.DB.mu.RUnlock()
        iter := s.DB.DB.NewIterator(util.BytesPrefix(iteratorPrefix), nil)
        defer iter.Release()

    if !input.ScanIndexForward {

    }

    if len(input.ExclusiveStartKey) > 0 {
        startPKAV, _ := input.ExclusiveStartKey[schema.PartitionKey]
        startSKAV, _ := input.ExclusiveStartKey[schema.SortKey]

        startPKVal, _ := model.GetAttributeValueString(startPKAV)
        startSKVal, _ := model.GetAttributeValueString(startSKAV)

        exclusiveKey := model.BuildLevelDBKey(input.TableName, startPKVal, startSKVal)

        if iter.Seek([]byte(exclusiveKey)) {
             iter.Next()
        }
    } else {
        iter.First()
    }

        output := QueryOutput{Items: []model.Record{}}

        limit := input.Limit 
        if limit <= 0 { limit = 1000 } 

        for i := 0; i < int(limit) && iter.Valid(); iter.Next() {

                var value []byte
                var err error
                var record model.Record

                if isGSIQuery {
                        key := iter.Key()
                        keyParts := strings.Split(string(key), model.GSIKeySeparator)
                        if len(keyParts) < 4 { continue }

                        basePKVal := keyParts[len(keyParts)-1]

                        mainKey := model.BuildLevelDBKey(input.TableName, basePKVal, "") 
                        value, err = s.DB.DB.Get([]byte(mainKey), nil)
                } else {
                        value = iter.Value()
                }

                if err != nil && err != leveldb.ErrNotFound {
                        continue
                }

                if err == leveldb.ErrNotFound { continue }

                record, err = model.UnmarshalRecord(value)
                if err != nil {
                        continue
                }

                output.Items = append(output.Items, record)
                output.Count++
                output.ScannedCount++
                i++

                if i == int(limit) && iter.Next() {
                        output.LastEvaluatedKey = record
                        iter.Prev()
                        break
                }
        }

        responseBody, _ := json.Marshal(output)
        w.WriteHeader(http.StatusOK)
        w.Write(responseBody)
}

type TransactWriteItem struct {
        ConditionCheck *struct {
                TableName string `json:"TableName"`
                Key model.Record `json:"Key"`
                ConditionExpression string `json:"ConditionExpression"`
                ExpressionAttributeValues map[string]model.AttributeValue `json:"ExpressionAttributeValues"`
        } `json:"ConditionCheck,omitempty"`
        Put *struct {
                Item model.Record `json:"Item"`
                TableName string `json:"TableName"`
        } `json:"Put,omitempty"`
        Delete *struct {
                Key model.Record `json:"Key"`
                TableName string `json:"TableName"`
        } `json:"Delete,omitempty"`
}

type TransactWriteItemsInput struct {
        TransactItems []TransactWriteItem `json:"TransactItems"`
}

func (s *Server) handleTransactWriteItems(w http.ResponseWriter, body []byte) {
        var input TransactWriteItemsInput
        if err := json.Unmarshal(body, &input); err != nil {
                s.writeDynamoDBError(w, "ValidationException", "Invalid JSON input", http.StatusBadRequest)
                return
        }

        batch := new(leveldb.Batch)

        s.DB.mu.Lock()
        defer s.DB.mu.Unlock()

        for _, item := range input.TransactItems {
                if item.ConditionCheck != nil {

                }
        }

        for _, item := range input.TransactItems {
                var tableName string
                var key model.Record
                var itemData model.Record
                var opType string

                if item.Put != nil {
                        tableName = item.Put.TableName
                        itemData = item.Put.Item
                        opType = "PUT"
                } else if item.Delete != nil {
                        tableName = item.Delete.TableName
                        key = item.Delete.Key
                        opType = "DELETE"
                } else if item.ConditionCheck != nil {
                        continue
                } else {
                        s.writeDynamoDBError(w, "ValidationException", "Invalid TransactItem structure.", http.StatusBadRequest)
                        return
                }

                schema, ok := s.DB.Tables[tableName]
                if !ok {
                        s.writeDynamoDBError(w, "ResourceNotFoundException", fmt.Sprintf("Table %s not found", tableName), http.StatusBadRequest)
                        return
                }

                pkAV, _ := key[schema.PartitionKey]
                if opType == "PUT" { pkAV = itemData[schema.PartitionKey] }

                pkVal, _ := model.GetAttributeValueString(pkAV)

                var skVal string
                if schema.SortKey != "" {
                        skAV, _ := key[schema.SortKey]
                        if opType == "PUT" { skAV = itemData[schema.SortKey] }
                        skVal, _ = model.GetAttributeValueString(skAV)
                }

                levelDBKey := model.BuildLevelDBKey(tableName, pkVal, skVal)

                if opType == "PUT" {
                        oldValue, err := s.DB.DB.Get([]byte(levelDBKey), nil)
                        var oldRecord model.Record
                        if err != leveldb.ErrNotFound && err != nil {
                                http.Error(w, "Internal DB error", http.StatusInternalServerError)
                                return
                        }
                        if err == nil {
                                oldRecord, _ = model.UnmarshalRecord(oldValue)
                        }

                        s.updateGSI(batch, schema, oldRecord, itemData)

                        value, _ := model.MarshalRecord(itemData)
                        batch.Put([]byte(levelDBKey), value)
                } else if opType == "DELETE" {
                        oldValue, err := s.DB.DB.Get([]byte(levelDBKey), nil)
                        var oldRecord model.Record
                        if err != leveldb.ErrNotFound && err != nil {
                                http.Error(w, "Internal DB error", http.StatusInternalServerError)
                                return
                        }
                        if err == nil {
                                oldRecord, _ = model.UnmarshalRecord(oldValue)
                        }
                        s.updateGSI(batch, schema, oldRecord, nil) 

                        batch.Delete([]byte(levelDBKey))
                }
        }

        if err := s.DB.DB.Write(batch, nil); err != nil {
                http.Error(w, "Internal DB error during transaction", http.StatusInternalServerError)
                return
        }

        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{}`))
}

type DeleteItemInput struct {
        TableName string `json:"TableName"`
        Key map[string]model.AttributeValue `json:"Key"`
        ReturnValues string `json:"ReturnValues,omitempty"`
}

func (s *Server) handleDeleteItem(w http.ResponseWriter, body []byte) {
        var input DeleteItemInput
        if err := json.Unmarshal(body, &input); err != nil {
                s.writeDynamoDBError(w, "ValidationException", "Invalid JSON input for DeleteItem", http.StatusBadRequest)
                return
        }

        s.DB.mu.RLock()
        schema, ok := s.DB.Tables[input.TableName]
        s.DB.mu.RUnlock()
        if !ok {
                s.writeDynamoDBError(w, "ResourceNotFoundException", "Table not found", http.StatusBadRequest)
                return
        }

        pkAV, ok := input.Key[schema.PartitionKey]
        if !ok {
                s.writeDynamoDBError(w, "ValidationException", fmt.Sprintf("Partition Key '%s' value missing in Key", schema.PartitionKey), http.StatusBadRequest)
                return
        }
        pkVal, _ := model.GetAttributeValueString(pkAV)

        var skVal string
        if schema.SortKey != "" {
                if skAV, ok := input.Key[schema.SortKey]; ok {
                        skVal, _ = model.GetAttributeValueString(skAV)
                }
        }
        levelDBKey := model.BuildLevelDBKey(input.TableName, pkVal, skVal)

        s.DB.mu.Lock()
        defer s.DB.mu.Unlock()

        oldValue, err := s.DB.DB.Get([]byte(levelDBKey), nil)
        if err == leveldb.ErrNotFound {
                w.WriteHeader(http.StatusOK)
                w.Write([]byte(`{}`))
                return
        }
        if err != nil {
                http.Error(w, "Internal DB error on retrieve", http.StatusInternalServerError)
                return
        }

        oldRecord := make(model.Record)
        if err := model.UnmarshalRecord(oldValue, &oldRecord); err != nil {
                http.Error(w, "Failed to unmarshal existing item", http.StatusInternalServerError)
                return
        }

        batch := new(leveldb.Batch)
        s.updateGSI(batch, schema, oldRecord, nil) 

        batch.Delete([]byte(levelDBKey))

        if err := s.DB.DB.Write(batch, nil); err != nil {
                http.Error(w, "Internal DB error on write", http.StatusInternalServerError)
                return
        }

    responseBody := []byte(`{}`)
    if input.ReturnValues == "ALL_OLD" {
        marshaledOldRecord, _ := json.Marshal(oldRecord)
        responseBody = []byte(fmt.Sprintf(`{"Attributes": %s}`, marshaledOldRecord))
    }

        w.WriteHeader(http.StatusOK)
        w.Write(responseBody)
}

func (s *Server) writeDynamoDBError(w http.ResponseWriter, errorType string, message string, status int) {
        w.WriteHeader(status)
        w.Header().Set("Content-Type", "application/x-amz-json-1.0")
        fmt.Fprintf(w, `{"__type": "com.amazon.coral.service#%s", "message": "%s"}`, errorType, message)
}

// --- Update Expression Logic ---

type UpdateActions struct {
        Set map[string]model.AttributeValue
        Add map[string]model.AttributeValue
        Remove []string
        Delete map[string]model.AttributeValue
}

func resolveAttributeName(input *model.UpdateItemInput, attrPath string) (string, error) {
        if strings.HasPrefix(attrPath, "#") {
                if resolvedName, ok := input.ExpressionAttributeNames[attrPath]; ok {
                        return resolvedName, nil
                } else {
                        return "", fmt.Errorf("attribute name alias %s not defined", attrPath)
                }
        }
        return attrPath, nil
}

func resolveAttributeValue(input *model.UpdateItemInput, valPlaceholder string) (model.AttributeValue, error) {
        if val, ok := input.ExpressionAttributeValues[valPlaceholder]; ok {
                return val, nil
        }
        return nil, fmt.Errorf("attribute value placeholder %s not defined", valPlaceholder)
}

func (s *Server) parseUpdateExpression(input *model.UpdateItemInput) (*UpdateActions, error) {
        actions := &UpdateActions{
                Set: make(map[string]model.AttributeValue),
                Add: make(map[string]model.AttributeValue),
                Delete: make(map[string]model.AttributeValue),
                Remove: []string{},
        }

        expression := input.UpdateExpression
        clauses := strings.Split(expression, " ")

        currentAction := ""

        for _, clause := range clauses {
                upperClause := strings.ToUpper(clause)
                if upperClause == "SET" || upperClause == "ADD" || upperClause == "REMOVE" || upperClause == "DELETE" {
                        currentAction = upperClause
                        continue
                }

                if currentAction == "" {
                        continue
                }

                updates := strings.Split(clause, ",")
                for _, update := range updates {
                        update = strings.TrimSpace(update)
                        if update == "" {
                                continue
                        }

                        if currentAction == "SET" || currentAction == "ADD" || currentAction == "DELETE" {
                                parts := strings.Split(update, "=")
                                if len(parts) != 2 {
                                        return nil, fmt.Errorf("invalid %s clause syntax: %s", currentAction, update)
                                }

                                attrPath := strings.TrimSpace(parts[0])
                                valPlaceholder := strings.TrimSpace(parts[1])

                                realAttrName, err := resolveAttributeName(input, attrPath)
                                if err != nil { return nil, err }

                                realValue, err := resolveAttributeValue(input, valPlaceholder)
                                if err != nil { return nil, err }

                                switch currentAction {
                                case "SET":
                                        actions.Set[realAttrName] = realValue
                                case "ADD":
                                        actions.Add[realAttrName] = realValue
                                case "DELETE":
                                        actions.Delete[realAttrName] = realValue
                                }
                        } else if currentAction == "REMOVE" {
                                attrPath := strings.TrimSpace(update)
                                realAttrName, err := resolveAttributeName(input, attrPath)
                                if err != nil { return nil, err }
                                actions.Remove = append(actions.Remove, realAttrName)
                        }
                }
        }

        return actions, nil
}

func applyAdd(oldRecord model.Record, attrName string, addValue model.AttributeValue) error {
        for k, v := range addValue {
                switch k {
                case "N":
                        if len(oldRecord[attrName]) == 0 {
                                oldRecord[attrName] = addValue
                                return nil
                        }

                        oldNumStr, ok := oldRecord[attrName]["N"].(string)
                        if !ok {
                                return fmt.Errorf("ADD failed: attribute %s is not a Number", attrName)
                        }
                        newNumStr, ok := addValue["N"].(string)
                        if !ok {
                                return fmt.Errorf("ADD failed: input value is not a Number", attrName)
                        }

                        var oldNum, newNum float64
                        fmt.Sscanf(oldNumStr, "%f", &oldNum)
                        fmt.Sscanf(newNumStr, "%f", &newNum)

                        sum := oldNum + newNum
                        oldRecord[attrName] = model.AttributeValue{"N": fmt.Sprintf("%f", sum)}

                case "NS":
                        oldSet := map[string]struct{}{}
                        if oldAV, ok := oldRecord[attrName]; ok {
                                if oldNS, ok := model.GetNumberSet(oldAV); ok {
                                        for _, item := range oldNS { oldSet[item] = struct{}{} }
                                }
                        }

                        newNS, ok := model.GetNumberSet(addValue)
                        if !ok {
                                return fmt.Errorf("ADD failed: input value is not a Number Set")
                        }

                        for _, item := range newNS { oldSet[item] = struct{}{} }

                        resultList := make([]string, 0, len(oldSet))
                        for item := range oldSet { resultList = append(resultList, item) }

                        interfaceList := make([]interface{}, len(resultList))
                        for i, v := range resultList { interfaceList[i] = v }

                        oldRecord[attrName] = model.AttributeValue{"NS": interfaceList}

                case "SS":
                        oldSet := map[string]struct{}{}
                        if oldAV, ok := oldRecord[attrName]; ok {
                                if oldSS, ok := model.GetStringSet(oldAV); ok {
                                        for _, item := range oldSS { oldSet[item] = struct{}{} }
                                }
                        }

                        newSS, ok := model.GetStringSet(addValue)
                        if !ok {
                                return fmt.Errorf("ADD failed: input value is not a String Set")
                        }

                        for _, item := range newSS { oldSet[item] = struct{}{} }

                        resultList := make([]string, 0, len(oldSet))
                        for item := range oldSet { resultList = append(resultList, item) }

                        interfaceList := make([]interface{}, len(resultList))
                        for i, v := range resultList { interfaceList[i] = v }

                        oldRecord[attrName] = model.AttributeValue{"SS": interfaceList}

                case "BS":
                        oldSet := map[string]struct{}{}
                        if oldAV, ok := oldRecord[attrName]; ok {
                                if oldBS, ok := model.GetBinarySet(oldAV); ok {
                                        for _, item := range oldBS { oldSet[item] = struct{}{} }
                                }
                        }

                        newBS, ok := model.GetBinarySet(addValue)
                        if !ok {
                                return fmt.Errorf("ADD failed: input value is not a Binary Set")
                        }

                        for _, item := range newBS { oldSet[item] = struct{}{} }

                        resultList := make([]string, 0, len(oldSet))
                        for item := range oldSet { resultList = append(resultList, item) }

                        interfaceList := make([]interface{}, len(resultList))
                        for i, v := range resultList { interfaceList[i] = v }

                        oldRecord[attrName] = model.AttributeValue{"BS": interfaceList}
                }
        }

        return nil
}

func applyDelete(oldRecord model.Record, attrName string, deleteValue model.AttributeValue) error {
        if len(oldRecord[attrName]) == 0 {
                return nil
        }

        for k, _ := range deleteValue {
                switch k {
                case "NS":
                        oldSet := map[string]struct{}{}
                        oldAV, ok := oldRecord[attrName]
                        if ok {
                                if oldNS, ok := model.GetNumberSet(oldAV); ok {
                                        for _, item := range oldNS { oldSet[item] = struct{}{} }
                                }
                        }

                        newNS, ok := model.GetNumberSet(deleteValue)
                        if !ok {
                                return fmt.Errorf("DELETE failed: input value is not a Number Set")
                        }

                        for _, item := range newNS { delete(oldSet, item) }

                        resultList := make([]string, 0, len(oldSet))
                        for item := range oldSet { resultList = append(resultList, item) }

                        if len(resultList) == 0 {
                                delete(oldRecord, attrName)
                        } else {
                                interfaceList := make([]interface{}, len(resultList))
                                for i, v := range resultList { interfaceList[i] = v }
                                oldRecord[attrName] = model.AttributeValue{"NS": interfaceList}
                        }

                case "SS":
                        oldSet := map[string]struct{}{}
                        oldAV, ok := oldRecord[attrName]
                        if ok {
                                if oldSS, ok := model.GetStringSet(oldAV); ok {
                                        for _, item := range oldSS { oldSet[item] = struct{}{} }
                                }
                        }

                        newSS, ok := model.GetStringSet(deleteValue)
                        if !ok {
                                return fmt.Errorf("DELETE failed: input value is not a String Set")
                        }

                        for _, item := range newSS { delete(oldSet, item) }

                        resultList := make([]string, 0, len(oldSet))
                        for item := range oldSet { resultList = append(resultList, item) }

                        if len(resultList) == 0 {
                                delete(oldRecord, attrName)
                        } else {
                                interfaceList := make([]interface{}, len(resultList))
                                for i, v := range resultList { interfaceList[i] = v }
                                oldRecord[attrName] = model.AttributeValue{"SS": interfaceList}
                        }

                case "BS":
                        oldSet := map[string]struct{}{}
                        oldAV, ok := oldRecord[attrName]
                        if ok {
                                if oldBS, ok := model.GetBinarySet(oldAV); ok {
                                        for _, item := range oldBS { oldSet[item] = struct{}{} }
                                }
                        }

                        newBS, ok := model.GetBinarySet(deleteValue)
                        if !ok {
                                return fmt.Errorf("DELETE failed: input value is not a Binary Set")
                        }

                        for _, item := range newBS { delete(oldSet, item) }

                        resultList := make([]string, 0, len(oldSet))
                        for item := range oldSet { resultList = append(resultList, item) }

                        if len(resultList) == 0 {
                                delete(oldRecord, attrName)
                        } else {
                                interfaceList := make([]interface{}, len(resultList))
                                for i, v := range resultList { interfaceList[i] = v }
                                oldRecord[attrName] = model.AttributeValue{"BS": interfaceList}
                        }
                default:
                        return fmt.Errorf("DELETE failed: unsupported attribute type for DELETE")
                }
        }
        return nil
}

func applyRemove(newRecord model.Record, attrName string) {
        delete(newRecord, attrName)
}

func (s *Server) handleUpdateItem(w http.ResponseWriter, body []byte) {
        var input model.UpdateItemInput
        if err := json.Unmarshal(body, &input); err != nil {
                s.writeDynamoDBError(w, "ValidationException", "Invalid JSON input for UpdateItem", http.StatusBadRequest)
                return
        }

        s.DB.mu.RLock()
        schema, ok := s.DB.Tables[input.TableName]
        s.DB.mu.RUnlock()
        if !ok {
                s.writeDynamoDBError(w, "ResourceNotFoundException", "Table not found", http.StatusBadRequest)
                return
        }

        pkAV, ok := input.Key[schema.PartitionKey]
        if !ok {
                s.writeDynamoDBError(w, "ValidationException", fmt.Sprintf("Partition Key '%s' value missing in Key", schema.PartitionKey), http.StatusBadRequest)
                return
        }
        pkVal, _ := model.GetAttributeValueString(pkAV)

        var skVal string
        if schema.SortKey != "" {
                if skAV, ok := input.Key[schema.SortKey]; ok {
                        skVal, _ = model.GetAttributeValueString(skAV)
                }
        }
        levelDBKey := model.BuildLevelDBKey(input.TableName, pkVal, skVal)

        s.DB.mu.Lock()
        defer s.DB.mu.Unlock()

        oldValue, err := s.DB.DB.Get([]byte(levelDBKey), nil)
        oldRecord := make(model.Record)
        if err != leveldb.ErrNotFound && err != nil {
                http.Error(w, "Internal DB error on retrieve", http.StatusInternalServerError)
                return
        }
        if err == nil {
                oldRecord, _ = model.UnmarshalRecord(oldValue)
        }

        actions, err := s.parseUpdateExpression(&input)
        if err != nil {
                s.writeDynamoDBError(w, "ValidationException", err.Error(), http.StatusBadRequest)
                return
        }

        newRecord := make(model.Record)
        for k, v := range oldRecord {
                newRecord[k] = v
        }

        for _, attrName := range actions.Remove {
                applyRemove(newRecord, attrName)
        }

        for attrName, deleteValue := range actions.Delete {
                if err := applyDelete(newRecord, attrName, deleteValue); err != nil {
                        s.writeDynamoDBError(w, "ValidationException", err.Error(), http.StatusBadRequest)
                        return
                }
        }

        for attrName, addValue := range actions.Add {
                if err := applyAdd(newRecord, attrName, addValue); err != nil {
                        s.writeDynamoDBError(w, "ValidationException", err.Error(), http.StatusBadRequest)
                        return
                }
        }

        for attrName, setValue := range actions.Set {
                newRecord[attrName] = setValue
        }

    if _, ok := actions.Set[schema.PartitionKey]; ok || len(actions.Add[schema.PartitionKey]) > 0 {
        s.writeDynamoDBError(w, "ValidationException", "Cannot update Partition Key", http.StatusBadRequest)
        return
    }
    if schema.SortKey != "" {
        if _, ok := actions.Set[schema.SortKey]; ok || len(actions.Add[schema.SortKey]) > 0 {
             s.writeDynamoDBError(w, "ValidationException", "Cannot update Sort Key", http.StatusBadRequest)
            return
        }
    }

        batch := new(leveldb.Batch)
        s.updateGSI(batch, oldRecord, newRecord)

        value, err := model.MarshalRecord(newRecord)
        if err != nil {
                s.writeDynamoDBError(w, "InternalServerError", "Failed to marshal updated item", http.StatusInternalServerError)
                return
        }
        batch.Put([]byte(levelDBKey), value)

        if err := s.DB.DB.Write(batch, nil); err != nil {
                http.Error(w, "Internal DB error on write", http.StatusInternalServerError)
                return
        }

    responseBody := []byte(`{}`)
    if input.ReturnValues == "ALL_NEW" {
        marshaledNewRecord, _ := json.Marshal(newRecord)
        responseBody = []byte(fmt.Sprintf(`{"Attributes": %s}`, marshaledNewRecord))
    }


        w.WriteHeader(http.StatusOK)
        w.Write(responseBody)
}